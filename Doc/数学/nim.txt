那么如果取到最后一个石子的人输呢？

首先考虑最简单的情况：每个堆中只有一枚石子，那么显然谁能获胜与堆的数目有关：如果堆的数目为奇数，先手必败，如果是偶数，则必胜。

如果只有一个堆中的石子数目大于1，先手必胜，因为如果此时有奇数个大小为1的堆，他可以把大于1的那个堆中的石子取完；如果有偶数个大小为1的堆，那么他可以把大于1的那个堆变为只包含一个石子的堆。这样后手将面对奇数个大小为1的堆。

如果有两个或两个以上的堆中包含的石子数目大于1呢？由于两个人都不可能一下把多个石子数大于1的堆变为没有大于1的堆，所以肯定会有一个人拿玩石子后，只剩下一个大小大于1的堆，这时下一个要拿石子的人将获胜。那么怎样判断谁会面对只有一堆石子数目大于1的状态呢？可以发现，只有一堆石子数目大于1的时候，Nim-Sum肯定不为0，所以如果初始状态下的Nim-Sum为0，那么先手必败，否则先手必胜。证明的思路是：如果Nim-Sum为0，那么下一个人不论怎样拿，只要按照规则，一定会使Nim-Sum不为0；如果Nim-Sum不为0，下一个人一定有一种拿石子的方法可以让Nim-Sum变成0。

写成程序（n表示堆数，n1表示大小为1的堆的数目，num[i]表示第i堆中的石子数）

Solve (int n, int num[]) {

         n1 = 0;

        for (i = 1; i <= n; i++) {

                if (num[i] > 1) n1++;

        }

        if (n1 == n) {

                if (n1 % 2 == 1) 先手败

                else                   先手胜

        }

        else if (n1 + 1 == n) 先手胜

        else {

               Nim_Sum = 0;

               for (i = 1; i <= n; i++) {

                        Nim_Sum ^= num[i];

               }

                if (Nim_Sum == 0) 先手败

               else                        先手胜

}
